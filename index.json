{
  "index.html": {
    "href": "index.html",
    "title": "Clippit - fresh PowerTools for OpenXml | Clippit",
    "keywords": "Clippit - fresh PowerTools for OpenXml Why Clippit? Clippit is a fork of Open-Xml-PowerTools (currently owned by Eric White) with new features, fixes and performance optimizations. Key highlights: Shipped as new NuGet package published from latest master . Target netstandard2.0 and uses latest C# language features. Continuously tested on Windows, macOS and Linux. Can be used side-by-side with any existing Open-Xml-PowerTools assembly. Key features: Provides optimized slide publishing API and improved PresentationBuilder ISource extensibility model for DocumentBuilder and new TableCellSource . SpreadsheetWriter that is able to generate multi-spreadsheet Excel files with data formatted as table and compatible with Power BI. Most of existing content about Open-Xml-PowerTools is still relevant: DocumentBuilder Resource Center PresentationBuilder Resource Center WmlToHtmlConverter Resource Center DocumentAssembler Resource Center About Open-XML-PowerTools The Open XML PowerTools provides guidance and example code for programming with Open XML Documents (DOCX, XLSX, and PPTX). It is based on, and extends the functionality of the Open XML SDK . It supports scenarios such as: Splitting DOCX/PPTX files into multiple files. Combining multiple DOCX/PPTX files into a single file. Populating content in template DOCX files with data from XML. High-fidelity conversion of DOCX to HTML/CSS. High-fidelity conversion of HTML/CSS to DOCX. Searching and replacing content in DOCX/PPTX using regular expressions. Managing tracked-revisions, including detecting tracked revisions, and accepting tracked revisions. Updating Charts in DOCX/PPTX files, including updating cached data, as well as the embedded XLSX. Comparing two DOCX files, producing a DOCX with revision tracking markup, and enabling retrieving a list of revisions. Retrieving metrics from DOCX files, including the hierarchy of styles used, the languages used, and the fonts used. Writing XLSX files using far simpler code than directly writing the markup, including a streaming approach that enables writing XLSX files with millions of rows. Extracting data (along with formatting) from spreadsheets. Copyright (c) Microsoft Corporation 2012-2017 Portions Copyright (c) Eric White Inc 2018-2019 Portions Copyright (c) Sergey Tihon 2019-2025 Licensed under the MIT License."
  },
  "tutorials/excel/SpreadsheetWriter.html": {
    "href": "tutorials/excel/SpreadsheetWriter.html",
    "title": "Write Spreadsheet | Clippit",
    "keywords": "Write Spreadsheet Namespace: Clippit.Excel Save WorkbookDfn to stream/file. public static class SpreadsheetWriter { public static void WriteTo(this WorkbookDfn workbook, Stream stream) {...} } Fixes Added API to save to stream. SpreadsheetWriter Sample var wb = new WorkbookDfn() { Worksheets = new WorksheetDfn[] { new() { Name = \"MyFirstSheet\", TableName = \"NamesAndRates\", ColumnHeadings = new CellDfn[] { new() { Value = \"Name\", Bold = true, }, new() { Value = \"Age\", Bold = true, HorizontalCellAlignment = HorizontalCellAlignment.Left, }, new() { Value = \"Rate\", Bold = true, HorizontalCellAlignment = HorizontalCellAlignment.Left, } }, Rows = new RowDfn[] { new() { Cells = new CellDfn[] { new() { CellDataType = CellDataType.String, Value = \"Eric\", }, new() { CellDataType = CellDataType.Number, Value = 50, }, new() { CellDataType = CellDataType.Number, Value = (decimal)45.00, FormatCode = \"0.00\", }, } }, new() { Cells = new CellDfn[] { new() { CellDataType = CellDataType.String, Value = \"Bob\", }, new() { CellDataType = CellDataType.Number, Value = 42, }, new() { CellDataType = CellDataType.Number, Value = (decimal)78.00, FormatCode = \"0.00\", }, } }, } } } }; using var stream = new MemoryStream(); wb.WriteTo(stream); var bytes = stream.ToArray();"
  },
  "tutorials/index.html": {
    "href": "tutorials/index.html",
    "title": "Introduction | Clippit",
    "keywords": "Introduction Welcome to Clippit library usage guide. If you don't know what Clippit is - please check Home Page . Please check navigation on the left â¬… for more articles. Requirements Clippit library should work with any framework version supported by .NET Standard 2.0 or greater. However, it is guaranteed only with .NET 5 and up - I did not test .NET Framework, Mono, Xamarin or Unity. Questions? To ask questions or share ideas, feel free to start a new GitHub Discussion . Any bugs? Requesting a specific feature? Please create a new Issue on GitHub . To contact me directly, you can find me on Twitter ."
  },
  "tutorials/powerpoint/BuildPresentation.html": {
    "href": "tutorials/powerpoint/BuildPresentation.html",
    "title": "Build Presentation | Clippit",
    "keywords": "Build Presentation Namespace: Clippit.PowerPoint Combine collection of SlideSource 's into one PowerPoint presentations. public static class PresentationBuilder { public static PmlDocument BuildPresentation(List<SlideSource> sources) {...} } Original behavior is documented at Eric's blog: http://www.ericwhite.com/blog/presentationbuilder-developer-center/ Major changes Removed Custom Properties . Clippit does not copy document properties from the first SlideSource into result document. Removed Section List . Clippit copy all slides into Default section and does not copy list of sections from first SlideSource . Structural comparison for Theme, Master, Layout . Clippit structurally compare Themes, Masters and Layout and maintain minimal amount of these parts in target presentation to guarantee no visual artifacts on slides in the target presentation. Shape auto-scale . Clippit automatically scale all shapes on the slides when you merge slides of different size. Fixes Appropriate file extentions generated for ImageParts based on ContentType (instead of *.bin for all images) Fixed multiple write access to the same part Optimized Stream lifetime and GC pressure BuildPresentation Sample var sources = new List<SlideSource>() { new SlideSource(new PmlDocument(file1), start:0, count:1, keepMaster:true), new SlideSource(new PmlDocument(file2), start:9, count:3, keepMaster:false) }; PresentationBuilder.BuildPresentation(sources) .SaveAs(resultFile); This code combines slides from two PowerPoint presentations: It takes Title slide from file1 and copy master using by first slide (with all layouts) Then copy three slides from file2 starting from slide 10 without master (reusing master and layouts moved from file1 )"
  },
  "tutorials/powerpoint/BuildPresentation_PublishSlides.html": {
    "href": "tutorials/powerpoint/BuildPresentation_PublishSlides.html",
    "title": "Slide Publishing | Clippit",
    "keywords": "Slide Publishing Namespace: Clippit.PowerPoint Split PowerPoint presentation ( PmlDocument ) into lazy sequence of one-slide presentations. public static class PresentationBuilder { public static IEnumerable<PmlDocument> PublishSlides(PmlDocument src) {...} } This is fully managed alternative of Presentation.PublishSlides that does not require MS Office to be installed on the machine. Key facts All extracted slides are marked as visible (even if they were hidden in the source presentation) Generated slides contain only one master with only one used layout (master will be renamed). Behavior is similar to Presentation.PublishSlides and allow to dramatically decrease total size of generated slides. PublishSlides is up to 6x times faster than BuildPresentation for the same task (Because we open source presentation only once) Slide title promoted to generated presentation title (when layout has slide). Last modified date propagated from source document. Publishing sample var presentation = new PmlDocument(sourcePath); var slides = PresentationBuilder.PublishSlides(presentation) foreach (var slide in slides) { var targetPath = Path.Combine(targetDir, Path.GetFileName(slide.FileName)) slide.SaveAs(targetPath); } Composing slides to one presentation You can combine generate slide back to one presentation without breaking them var presentation = new PmlDocument(sourceFile); var slides = PresentationBuilder.PublishSlides(presentation).ToList(); var sources = slides.Select(x => new SlideSource(x, keepMaster:true)).ToList(); PresentationBuilder.BuildPresentation(sources) .SaveAs(newFileName); this code will generate presentation with multiple one-layout masters. If you want to have full master inside your generated presentation the first slide source should carry this master var presentation = new PmlDocument(sourceFile); // generate presentation with all masters var onlyMasters = PresentationBuilder.BuildPresentation( new List<SlideSource> { new SlideSource(presentation, start:0, count:0, keepMaster:true) }); // publish slides with one-layout masters var slides = PresentationBuilder.PublishSlides(presentation); // compose them together using only master as the first SlideSource var sources = new List<SlideSource> { new SlideSource(onlyMaster, keepMaster:true)}; sources.AddRange(slides.Select(x => new SlideSource(x, keepMaster:false))); PresentationBuilder.BuildPresentation(sources) .SaveAs(newFileName);"
  },
  "tutorials/word/DocumentAssembler_DocumentTemplates.html": {
    "href": "tutorials/word/DocumentAssembler_DocumentTemplates.html",
    "title": "Inserting Documents or Document Templates into Word Files using Document Assembler | Clippit",
    "keywords": "Inserting Documents or Document Templates into Word Files using Document Assembler Introduction DocumentAssembler has added the Document and DocumentTemplate elements for inserting entire Word documents into the output of an assembled document. This enables some interesting use cases and also allows developers using DocumentAssembler to componentise large templates with re-usable blocks. Document Element Usage The Document element will take either a File path or a base64 encoded string that represents a Word document: <Document Path=\"C:\\Temp\\My Document.docx\" /> Or <Document Data=\"base64encodedstring\" /> The Document element can only be used at the block level and not within a run. DocumentTemplate Element Usage The DocumentTemplate element builds upon the Document element by taking a Select attribute which is the XML data you want to pass to the template. Note that the Select element changes the context of the XML node. This can make for easier to read templates. For example say we had the following XML document: <xml> <invoice> <line-items> <line-item> <description>Mens Jeans</description> <amount>Â£40.00</amount> </line-item> <line-item> <description>T-Shirt<description> <amount>Â£15.00</amount> <line-item> </line-items> <total> <amount>Â£55.00</amount> </total> </invoice> </xml> The in a single file template we could address that as follows: <Repeat Select=\"invoice/line-items/line-item\" /> <Content Select=\"description\" /> - <Content Select=\"amount\" /> </EndRepeat> Total: <Content Select=\"invoice/total/amount\" /> Using the DocumentTemplate element we could re-write the top-level template as: <DocumentTemplate Path=\"C:\\Templates\\Invoice-Lines.docx\" Select=\"invoice/line-items\" /> Total: <Content Select=\"invoice/total/amount\" /> Because we are passing in the context node then our Invoice-Lines.docx would then look like so: <Repeat Select=\"line-item\"> <Content Select=\"description\" /> - <Content Select=\"amount\" /> </Repeat> This is a contrived example, but in large templates with re-usable blocks then it can be very useful. Note that a template that is called by a DocumentTemplate element can have another DocumentTemplate within it. How your structure and re-use the templates is up to you. How Does it Work? To make this work we have introduced a dependency on DocumentBuilder in DocumentAssembler . We then perform the operation in two passes: 1. Inline all Document and DocumentTemplate Elements Each Document and DocumentTemplate element is processed, and the data inlined as a Document element with a Data attribute. e.g. <Document Data=\"base64encodedstring\" /> 2. DocumentBuilder combines all Document elements Once DocumentAssembler has finished processing, we build a collection of Sources and pass that to DocumentBuilder which handles the complex job of merging the output document and all inlined Document elements into a single output document."
  },
  "tutorials/word/DocumentAssembler_ImagesSupport.html": {
    "href": "tutorials/word/DocumentAssembler_ImagesSupport.html",
    "title": "Key highlights from #31 | Clippit",
    "keywords": "Key highlights from #31 Introduction The Image content control works by being placed directly before an image placeholder in your Word document. The image placeholder must be inline. Images content can be provided in your XML data using a path to a file on disk, or by using the data URI scheme . Example of both approaches are shown below: <Logo>../../md-logo.png</Logo> <Image>data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAgGBgcGBQgHBwcetcâ€¦</Image> Document Assembler will either infer the MIME type based on the extension of the filename, or take use the MIME type passed in when using the data URI scheme. Examples below show the Image content control in action and are taken from the Document Assembler Test Files: Image Select Image Select within a Repeat Note that when using a Repeat XPATH is aware of the Context it is in and should operate on the \"current\" Node. Image Select within a Table Works in a very similar way to Repeat. XML Data used in above Examples <?xml version=\"1.0\" encoding=\"utf-8\"?> <Customer> <CustomerID>1</CustomerID> <Name>Cheryl</Name> <HighValueCustomer>True</HighValueCustomer> <CustomerLogo>../../../../TestFiles/img.png</CustomerLogo> <Header>../../../../TestFiles/T0936_files/image001.png</Header> <Orders> <Order> <ProductDescription>Unicycle</ProductDescription> <Quantity>3</Quantity> <OrderDate>9/5/2001</OrderDate> <Thumbnail>../../../../TestFiles/img2.png</Thumbnail> </Order> <Order> <ProductDescription>Tricycle</ProductDescription> <Quantity>3</Quantity> <OrderDate>8/6/2000</OrderDate> <Thumbnail>data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMcAAACTCAYA...</Thumbnail> </Order> </Orders> <TotalQuantity>6</TotalQuantity> <Description><![CDATA[This is a multiline description that contains details about Cheryl.]]></Description> </Customer> Further Reading If you are interested in using the Image functionality in DocumentAssembler then your best bet is to look at DocumentAssemblerTests.cs and particularly the data files which can be found in the repository under Test Files/DA . Changes merged in: #31"
  },
  "tutorials/word/DocumentAssembler_InlineHtmlSupport.html": {
    "href": "tutorials/word/DocumentAssembler_InlineHtmlSupport.html",
    "title": "Inline HTML Support | Clippit",
    "keywords": "Inline HTML Support Introduction Document Assembler now supports basic inline HTML tags and if these are found in your Content select then formatting will be placed directly on the run. For example assuming you had an XML file with an HTML fragment such as: <doc> <fragment> <p>Document Assembler is <b>AWESOME!</b></p> <p>It now supports <u><i>simple</i></u> inline HTML.</p> </fragment> </doc> And you had a Content tag in your template: <Content Select=\"//fragment[1]\" /> Then Document Assembler would render this in Word as: Supported HTML tags Currently the following HTMl tags are supported. Block Tags Both div and p tags are supported for block level content. When Document Assembler finds either of these then it will treat them as an encapsulating paragraph. Inline Tags Either b or strong are supported for Bold Either i or em are support for Italic u is translated to Underline a will create a clickable Hyperlink in Word br forces a new line HTML Parsing HTML parsing is provided using the HTML Agility Pack and is fairly forgiving. If you have HTML elements in use that are not supported Document Assembler will simply ignore them and process the rest of your content. Usage in Templates Inline HTML formatting is supported by default, you do not need to change your Content elements, you just need to pass valid HTML rather than text to them in the Select attribute. Future Developments Inline HTML support is in it's infancy but it would make sense to add support for: Ordered lists ol Unordered lists ul Superscript sup Subscript sup Strike-through s"
  },
  "tutorials/word/DocumentBuilder_CustomISource.html": {
    "href": "tutorials/word/DocumentBuilder_CustomISource.html",
    "title": "Custom ISource implementation | Clippit",
    "keywords": "Custom ISource implementation Namespace: Clippit.Word ISource abstractions allow to use DocumentBuild with custom content selectors. public interface ISource : ICloneable { WmlDocument WmlDocument { get; set; } bool KeepSections { get; set; } public bool DiscardHeadersAndFootersInKeptSections { get; set; } string InsertId { get; set; } IEnumerable<XElement> GetElements(WordprocessingDocument document); } RecursiveTableCellSource Allow to reference tables inside tables [Serializable] public class TableCellReference { public int TableElementIndex { get; set; } public int RowIndex { get; set; } public int CellIndex { get; set; } } [Serializable] public class RecursiveTableCellSource : ISource { public WmlDocument WmlDocument { get => _wmlDocument; set => _wmlDocument = value; } [NonSerialized] private WmlDocument _wmlDocument; public bool KeepSections { get; set; } public bool DiscardHeadersAndFootersInKeptSections { get; set; } public string InsertId { get; set; } public List<TableCellReference> TableCellReferences { get; set; } public int Start { get; set; } public int Count { get; set; } public IEnumerable<XElement> GetElements(WordprocessingDocument document) { var body = document.MainDocumentPart.GetXDocument().Root?.Element(W.body); if (body is null) { throw new DocumentBuilderException( \"Unsupported document - contains no body element in the correct namespace\"); } var elements = body.Elements(); foreach (var cellRef in TableCellReferences) { var table = elements.Skip(cellRef.TableElementIndex).FirstOrDefault(); if (table is null || table.Name != W.tbl) { throw new DocumentBuilderException( $\"Invalid {nameof(RecursiveTableCellSource)} - element {cellRef.TableElementIndex} is '{table?.Name}' but expected {W.tbl}\"); } var row = table.Elements(W.tr).Skip(cellRef.RowIndex).FirstOrDefault(); if (row is null) { throw new DocumentBuilderException( $\"Invalid {nameof(RecursiveTableCellSource)} - row {cellRef.RowIndex} does not exist\"); } var cell = row.Elements(W.tc).Skip(cellRef.CellIndex).FirstOrDefault(); if (cell is null) { throw new DocumentBuilderException( $\"Invalid {nameof(RecursiveTableCellSource)} - cell {cellRef.CellIndex} in the row {cellRef.RowIndex} does not exist\"); } elements = cell.Elements(); } return elements .Skip(Start) .Take(Count) .ToList(); } public object Clone() => new RecursiveTableCellSource { WmlDocument = WmlDocument, KeepSections = KeepSections, DiscardHeadersAndFootersInKeptSections = DiscardHeadersAndFootersInKeptSections, InsertId = InsertId, TableCellReferences = TableCellReferences.Select(x => new TableCellReference { TableElementIndex = x.TableElementIndex, RowIndex = x.RowIndex, CellIndex = x.CellIndex, }).ToList(), Start = Start, Count = Count }; }"
  },
  "tutorials/word/DocumentBuilder_TableCellSource.html": {
    "href": "tutorials/word/DocumentBuilder_TableCellSource.html",
    "title": "Table Cell Source | Clippit",
    "keywords": "Table Cell Source Namespace: Clippit.Word TableCellSource allow to reference content of table cells. Document Builder sample var document = new WmlDocument(sourceFilePath); var sources = new List<ISource>() { new Source(document) { // Select range of 5 elements (most frequently paragraphs) // starting from element with id 0 Start = 0, Count = 5 }, new TableCellSource(document) { // Reference the table (element with index 5) // Take 1st row and 3rd row in that row TableElementIndex = 5, RowIndex = 0, CellIndex = 2, // Select range of 2 elements inside the cell // starting from element with id 0 CellContentStart = 0, CellContentCount = 2 } }; var newDocument = DocumentBuilder.BuildDocument(sources); newDocument.SaveAs(destinationFilePath);"
  }
}